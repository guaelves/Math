<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>‰πòÊ≥ï5Ê≥°Ê≥°ÈÅäÊà≤</title>
<style>
  body {
    font-family: "Microsoft JhengHei", sans-serif;
    text-align: center;
    background: #fff;
    margin: 0;
    padding: 20px;
  }
  h1 {
    font-size: 44px;
    margin: 6px 0 12px;
  }
  #question {
    font-size: 48px;
    margin: 12px 0 8px;
    font-weight: 700;
  }

  #bubbles {
    position: relative;
    width: 100%;
    height: 480px;
    margin: 12px 0 18px;
    border-radius: 8px;
    user-select: none;
    overflow: hidden;
  }

  .bubble {
    position: absolute;
    border: 2px solid #000;
    border-radius: 50%;
    background: #fff;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.25s ease, opacity 0.4s ease, background 0.25s ease;
    font-weight: 800;
    box-sizing: border-box;
  }

  .bubble.wrong {
    animation: bubble-burst 400ms forwards;
  }
  @keyframes bubble-burst {
    0% { transform: scale(1); opacity: 1; }
    60% { transform: scale(1.25); opacity: 1; }
    100% { transform: scale(0); opacity: 0; }
  }

  .bubble.correct {
    animation: bubble-pop 500ms forwards;
  }
  @keyframes bubble-pop {
    0% { transform: scale(1); }
    40% { transform: scale(1.4); }
    100% { transform: scale(1); }
  }

  #message {
    font-size: 32px;
    height: 44px;
    margin-bottom: 10px;
    color: #f44336;
    font-weight: 700;
  }

  .controls {
    margin-top: 6px;
  }

  button {
    font-size: 20px;
    margin: 8px;
    padding: 10px 18px;
    cursor: pointer;
    border: none;
    color: #000;
    border-radius: 10px;
  }
  #startBtn { background-color: #ffeb3b; } /* ÈªÉËâ≤ */
  #restartBtn { background-color: #b2fab4; } /* Ê∑°Á∂† */
  #tableBtn { background-color: #b3e5fc; }   /* Ê∑°Ëóç */

  /* small screen adjustments */
  @media (max-width: 420px) {
    #question { font-size: 52px; }
    #bubbles { height: 360px; }
    button { font-size: 18px; padding: 8px 14px; }
  }
</style>
</head>
<body>

<h1>‰πòÊ≥ï5Ê≥°Ê≥°ÈÅäÊà≤</h1>

<div id="startContainer">
  <button id="startBtn" aria-label="ÈñãÂßãÈÅäÊà≤">ÈñãÂßãÈÅäÊà≤</button>
</div>

<div id="gameContainer" style="display:none;">
  <div id="question" aria-live="polite"></div>
  <div id="bubbles" aria-hidden="false"></div>
  <div id="message" role="status" aria-live="assertive"></div>

  <div class="controls">
    <button id="restartBtn">ÈáçÊñ∞ÈñãÂßã</button>
    <button id="tableBtn" onclick="location.href='https://guaelves.github.io/Math/9981/'">ÂõûÂà∞‰πù‰πù‰πòÊ≥ïË°®Á∑¥Áøí</button>
  </div>
</div>

<script>
/* Game variables */
let currentQuestion = 0;
let correctAnswers = 0;
const totalQuestions = 9;

/* Generate one random question for multiplier 6 */
function getRandomQuestion() {
  const n = Math.floor(Math.random() * 9) + 1; // 1..9
  return { question: `5 √ó ${n}`, answer: 5 * n };
}

/* Generate bubbles array (one correct answer + nearby numbers)
   Fixes for small answers included (but 6's range is fine) */
function generateBubbles(correctAnswer) {
  const bubbles = [];
  const count = Math.floor(Math.random() * 2) + 5; // 5 or 6 bubbles
  const used = new Set([correctAnswer]);
  bubbles.push(correctAnswer);

  let attempts = 0;
  while (bubbles.length < count && attempts < 100) {
    attempts++;
    const offset = Math.floor(Math.random() * 3) + 1; // 1..3
    let choice;
    if (correctAnswer <= 3) {
      choice = correctAnswer + offset;
    } else {
      choice = Math.random() < 0.5 ? correctAnswer + offset : correctAnswer - offset;
      if (choice < 1) choice = correctAnswer + offset;
    }
    if (!used.has(choice)) {
      used.add(choice);
      bubbles.push(choice);
    }
  }

  // If still not enough (rare), fill upward
  let filler = correctAnswer + 1;
  while (bubbles.length < count) {
    if (!used.has(filler)) { used.add(filler); bubbles.push(filler); }
    filler++;
  }

  // shuffle
  for (let i = bubbles.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [bubbles[i], bubbles[j]] = [bubbles[j], bubbles[i]];
  }
  return bubbles;
}

/* Check overlapping circles */
function isOverlapping(x, y, size, placed) {
  for (const b of placed) {
    const dx = x - b.x, dy = y - b.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < (size / 2 + b.size / 2 + 8)) return true;
  }
  return false;
}

/* Random pastel color for correct bubble */
function randomPastel() {
  const r = Math.floor(160 + Math.random() * 80);
  const g = Math.floor(160 + Math.random() * 80);
  const b = Math.floor(160 + Math.random() * 80);
  return `rgb(${r},${g},${b})`;
}

/* Show one question: create bubbles with random sizes/positions (non-overlap) */
function showQuestion() {
  const q = getRandomQuestion();
  window.currentAnswer = q.answer;
  document.getElementById('question').textContent = q.question;

  // Auto speak the question
  if ('speechSynthesis' in window) {
    const utter = new SpeechSynthesisUtterance(q.question);
    utter.lang = 'zh-TW';
    // stop any previous
    window.speechSynthesis.cancel();
    window.speechSynthesis.speak(utter);
  }

  const bubblesDiv = document.getElementById('bubbles');
  bubblesDiv.innerHTML = '';
  document.getElementById('message').textContent = '';

  const bubbleNumbers = generateBubbles(q.answer);
  const placed = [];

  bubbleNumbers.forEach(num => {
    const el = document.createElement('div');
    el.className = 'bubble';
    // size 80~150
    const size = Math.floor(Math.random() * 70) + 80;
    el.style.width = `${size}px`;
    el.style.height = `${size}px`;
    // font size proportional
    el.style.fontSize = `${Math.floor(size / 2.2)}px`;

    // find a non-overlapping position (tries limited)
    let x, y, tries = 0;
    const containerW = bubblesDiv.clientWidth || 320;
    const containerH = bubblesDiv.clientHeight || 320;
    do {
      x = Math.random() * (containerW - size);
      y = Math.random() * (containerH - size);
      tries++;
    } while (isOverlapping(x + size/2, y + size/2, size, placed) && tries < 300);

    el.style.left = `${x}px`;
    el.style.top = `${y}px`;

    placed.push({ x: x + size/2, y: y + size/2, size });
    el.textContent = num;
    el.tabIndex = 0;
    el.setAttribute('role','button');

    el.addEventListener('click', () => handlePick(num, el), { once: true });
    el.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); handlePick(num, el); }
    });

    bubblesDiv.appendChild(el);
  });
}

/* Handle pick */
function handlePick(selected, el) {
  const msgDiv = document.getElementById('message');
  if (selected === window.currentAnswer) {
    // correct: color bubble with random pastel and pop animation
    const color = randomPastel();
    el.style.background = color;
    el.classList.add('correct');
    msgDiv.style.color = 'green';
    msgDiv.textContent = 'Á≠îÂ∞çÔºÅ';
    correctAnswers++;

    setTimeout(() => {
      currentQuestion++;
      if (currentQuestion < totalQuestions) {
        showQuestion();
      } else {
        document.getElementById('question').textContent = 'ÊÅ≠ÂñúüéâÂÖ®ÈÉ®Á≠îÂ∞çÔºÅ';
        document.getElementById('bubbles').innerHTML = '';
        msgDiv.textContent = '';
      }
    }, 700);

  } else {
    // wrong: red and burst
    el.style.background = '#f44336';
    el.classList.add('wrong');
    msgDiv.style.color = '#f44336';
    msgDiv.textContent = 'Á≠îÈåØÔºÅ';
  }
}

/* Start button */
document.getElementById('startBtn').addEventListener('click', () => {
  document.getElementById('startContainer').style.display = 'none';
  document.getElementById('gameContainer').style.display = 'block';
  currentQuestion = 0;
  correctAnswers = 0;
  showQuestion();
});

/* Restart always available */
document.getElementById('restartBtn').addEventListener('click', () => {
  currentQuestion = 0;
  correctAnswers = 0;
  // stop any speaking
  if ('speechSynthesis' in window) window.speechSynthesis.cancel();
  showQuestion();
});

/* Ensure game container size measured after load/resize */
window.addEventListener('resize', () => {
  // optional: could re-layout current question, but keep simple
});
</script>

</body>
</html>
